package aQute.bnd.plugin.spi;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.stream.Collectors;

import org.osgi.namespace.extender.ExtenderNamespace;

import aQute.bnd.annotation.spi.ServiceConsumer;
import aQute.bnd.header.Attrs;
import aQute.bnd.header.OSGiHeader;
import aQute.bnd.header.Parameters;
import aQute.bnd.osgi.Analyzer;
import aQute.bnd.osgi.Annotation;
import aQute.bnd.osgi.Clazz;
import aQute.bnd.osgi.Constants;
import aQute.bnd.osgi.Descriptors.PackageRef;
import aQute.bnd.osgi.Descriptors.TypeRef;
import aQute.bnd.osgi.EmbeddedResource;
import aQute.bnd.osgi.Instruction;
import aQute.bnd.osgi.Instructions;
import aQute.bnd.osgi.Processor;
import aQute.bnd.service.AnalyzerPlugin;
import aQute.bnd.version.Version;
import aQute.bnd.version.VersionRange;
import aQute.lib.exceptions.Exceptions;
import aQute.lib.strings.Strings;

public class SPIAnnotations implements AnalyzerPlugin {

	private static final Version	SLM_VERSION			= new Version(1);

	private static final String		SERVICE_CONSUMER	= "aQute/bnd/annotation/spi/ServiceConsumer";
	private static final String		SERVICE_CONSUMERS	= "aQute/bnd/annotation/spi/ServiceConsumers";
	private static final String		SERVICE_PROVIDER	= "aQute/bnd/annotation/spi/ServiceProvider";
	private static final String		SERVICE_PROVIDERS	= "aQute/bnd/annotation/spi/ServiceProviders";

	@Override
	public boolean analyzeJar(Analyzer analyzer) throws Exception {
		Parameters header = OSGiHeader.parseHeader(analyzer.getProperty(Constants.SPIANNOTATIONS, "*"));
		if (header.size() == 0)
			return false;

		Instructions instructions = new Instructions(header);
		Set<PackageRef> processed = new HashSet<>();

		Map<Annotation, Clazz> consumerTypes = new HashMap<>();
		Map<Annotation, Clazz> providerTypes = new HashMap<>();

		for (Clazz c : analyzer.getClassspace()
			.values()) {

			for (Entry<Instruction, Attrs> entry : instructions.entrySet()) {
				Instruction instruction = entry.getKey();
				if (instruction.matches(c.getFQN())) {
					if (instruction.isNegated()) {
						break;
					}

					PackageRef packageRef = c.getClassName()
						.getPackageRef();

					if (processed.add(packageRef)) {
						Clazz packageInfo = analyzer.getPackageInfo(packageRef);

						if (packageInfo != null) {
							processClazz(analyzer, packageInfo, consumerTypes, providerTypes);
						}
					}

					processClazz(analyzer, c, consumerTypes, providerTypes);
				}
			}
		}

		if (!consumerTypes.isEmpty()) {
			String requirements = consumerTypes.entrySet()
				.stream()
				.map(this::toRequirement)
				.collect(Collectors.joining(","));

			StringBuilder sb = new StringBuilder();
			sb.append(requirements);
			sb.append(",");
			sb.append(ExtenderNamespace.EXTENDER_NAMESPACE);
			sb.append(";filter:='(&(osgi.extender=osgi.serviceloader.processor)");
			sb.append(new VersionRange(SLM_VERSION, SLM_VERSION.bumpMajor()).toFilter());
			sb.append(")'");

			append(analyzer, Constants.REQUIRE_CAPABILITY, sb.toString());
		}

		if (!providerTypes.isEmpty()) {
			Set<Entry<Annotation, Clazz>> entrySet = providerTypes.entrySet();

			createServiceDescriptors(analyzer, entrySet);

			String capabilities = entrySet.stream()
				.map(this::toCapability)
				.collect(Collectors.joining(","));

			append(analyzer, Constants.PROVIDE_CAPABILITY, capabilities);

			StringBuilder sb = new StringBuilder();
			sb.append(ExtenderNamespace.EXTENDER_NAMESPACE);
			sb.append(";filter:='(&(osgi.extender=osgi.serviceloader.registrar)");
			sb.append(new VersionRange(SLM_VERSION, SLM_VERSION.bumpMajor()).toFilter());
			sb.append(")'");

			append(analyzer, Constants.REQUIRE_CAPABILITY, sb.toString());
		}

		return false;
	}

	private void createServiceDescriptors(Analyzer a, Set<Entry<Annotation, Clazz>> entrySet) {
		Map<String, ArrayList<String>> services = new HashMap<>();

		for (Entry<Annotation, Clazz> entry : entrySet) {
			String fqcn = ((TypeRef) entry.getKey()
				.get("value")).getFQN();
			ArrayList<String> list = services.computeIfAbsent(fqcn, k -> new ArrayList<>());
			list.add(entry.getValue()
				.getClassName()
				.getFQN());
		}

		for (Entry<String, ArrayList<String>> entry : services.entrySet()) {
			String key = "META-INF/services/" + entry.getKey();
			ArrayList<String> list = entry.getValue();
			list.add(0, "# Generated by bnd");
			String value = Strings.join("\n", entry.getValue());
			a.getJar()
				.putResource(key, new EmbeddedResource(value, a.lastModified()));
		}
	}

	void append(Analyzer analyzer, String key, String value) {
		analyzer.setProperty(key, Processor.append(analyzer.getProperty(key), value));
	}

	String toCapability(Entry<Annotation, Clazz> entry) {
		TypeRef serviceType = entry.getKey()
			.get("value");

		StringBuilder sb = new StringBuilder();
		sb.append("osgi.serviceloader;osgi.serviceloader='");
		sb.append(serviceType.getFQN());
		sb.append("'");
		sb.append(";register:=");
		sb.append(entry.getValue()
			.getClassName()
			.getFQN());

		Annotation annotation = entry.getKey();

		Object[] attributes = annotation.get("attribute");

		if (attributes != null) {
			for (Object attribute : attributes) {
				sb.append(";");
				sb.append(String.valueOf(attribute));
			}
		}

		TypeRef[] uses = annotation.get("uses");

		if (uses != null) {
			sb.append(";uses:='");
			sb.append(Arrays.stream(uses)
				.map(tr -> tr.getPackageRef()
					.getFQN())
				.collect(Collectors.joining(",")));
			sb.append("'");
		}

		return sb.toString();
	}

	String toRequirement(Entry<Annotation, Clazz> entry) {
		try {
			ServiceConsumer serviceConsumer = entry.getKey()
				.getAnnotation();

			TypeRef serviceType = entry.getKey()
				.get("value");

			StringBuilder sb = new StringBuilder();
			sb.append("osgi.serviceloader;osgi.serviceloader='");
			sb.append(serviceType.getFQN());
			sb.append("';filter:='(osgi.serviceloader=");
			sb.append(serviceType);
			sb.append(")'");
			sb.append(";cardinality:=");
			sb.append(serviceConsumer.cardinality()
				.toString()
				.toLowerCase());
			sb.append(";effective:=");
			sb.append(serviceConsumer.effective()
				.toString()
				.toLowerCase());
			sb.append(";resolution:=");
			sb.append(serviceConsumer.resolution()
				.toString()
				.toLowerCase());

			return sb.toString();
		} catch (Exception e) {
			throw Exceptions.duck(e);
		}
	}

	private void processClazz(Analyzer analyzer, Clazz c, Map<Annotation, Clazz> consumerTypes,
		Map<Annotation, Clazz> providerTypes) {

		c.annotations(SERVICE_CONSUMERS)
			.flatMap(a -> Arrays.stream((Object[]) a.get("value")))
			.map(Annotation.class::cast)
			.forEach(a -> consumerTypes.put(a, c));

		c.annotations(SERVICE_CONSUMER)
			.forEach(a -> consumerTypes.put(a, c));

		c.annotations(SERVICE_PROVIDERS)
			.flatMap(a -> Arrays.stream((Object[]) a.get("value")))
			.map(Annotation.class::cast)
			.forEach(a -> providerTypes.put(a, c));

		c.annotations(SERVICE_PROVIDER)
			.forEach(a -> providerTypes.put(a, c));
	}

}
